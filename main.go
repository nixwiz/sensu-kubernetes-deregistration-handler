package main

import (
	"context"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/url"
	"os"

	"github.com/sensu-community/sensu-plugin-sdk/httpclient"
	"github.com/sensu-community/sensu-plugin-sdk/sensu"
	corev2 "github.com/sensu/sensu-go/api/core/v2"
)

const (
	kubernetesDeleteCheckName = "kubernetes-delete-entity"
)

// Config represents the handler plugin config.
type Config struct {
	sensu.PluginConfig
	APIURL             string
	APIKey             string
	TrustedCAFile      string
	InsecureSkipVerify bool
}

var (
	plugin = Config{
		PluginConfig: sensu.PluginConfig{
			Name:     "sensu-kubernetes-deregistration-handler",
			Short:    "Sensu Handler to deregister entities created by the Sensu Kubernetes Events check",
			Keyspace: "sensu.io/plugins/sensu-kubernetes-deregistration-handler/config",
		},
	}

	options = []*sensu.PluginConfigOption{
		{
			Path:      "apiURL",
			Env:       "SENSU_API_URL",
			Argument:  "apiURL",
			Shorthand: "u",
			Default:   "http://127.0.0.1:8080",
			Usage:     "Sensu Go Backend URL",
			Value:     &plugin.APIURL,
		},
		{
			Path:      "apiKey",
			Env:       "SENSU_API_KEY",
			Argument:  "apiKey",
			Shorthand: "k",
			Secret:    true,
			Default:   "",
			Usage:     "Sensu Go Backend API Key",
			Value:     &plugin.APIKey,
		},
		{
			Path:      "insecure-skip-verify",
			Env:       "",
			Argument:  "insecure-skip-verify",
			Shorthand: "i",
			Default:   false,
			Usage:     "skip TLS certificate verification (not recommended!)",
			Value:     &plugin.InsecureSkipVerify,
		},
		{
			Path:      "trusted-ca-file",
			Env:       "",
			Argument:  "trusted-ca-file",
			Shorthand: "t",
			Default:   "",
			Usage:     "TLS CA certificate bundle in PEM format",
			Value:     &plugin.TrustedCAFile,
		},
	}
)

func main() {
	goHandler := sensu.NewGoHandler(&plugin.PluginConfig, options, checkArgs, executeHandler)
	goHandler.Execute()
}

func checkArgs(event *corev2.Event) error {
	if len(plugin.APIURL) == 0 {
		return fmt.Errorf("No API URL specified, please specify --apiURL or set env var SENSU_API_URL")
	}

	_, err := url.Parse(plugin.APIURL)
	if err != nil {
		return fmt.Errorf("Invalid value for --apiURL: %s", err)
	}

	if len(plugin.APIKey) == 0 {
		return fmt.Errorf("No API Key specified, please specify --apiKey or set env var SENSU_API_KEY")
	}

	return nil
}

func executeHandler(event *corev2.Event) error {
	// Since this handler is meant to only act on events generated by the
	// sensu-kubernetes-events check, expect a specially named check in order
	// to actually process this as a deregistration event
	if event.Check.Name != kubernetesDeleteCheckName {
		return fmt.Errorf("Received an unexpected event from check %s, not deregistering %s", event.Check.Name, event.Entity.Name)
	}

	config := httpclient.CoreClientConfig{
		URL:                plugin.APIURL,
		APIKey:             plugin.APIKey,
		InsecureSkipVerify: plugin.InsecureSkipVerify,
	}
	if plugin.TrustedCAFile != "" {
		file, err := os.Open(plugin.TrustedCAFile)
		if err != nil {
			return fmt.Errorf("Unable to open trusted-ca-file: %s", err)
		}
		config.CACert, err = readCAFile(file)
		if err != nil {
			return err
		}

	}
	client := httpclient.NewCoreClient(config)
	resource, err := httpclient.NewResourceRequest("core/v2", "Entity", event.Entity.Namespace, event.Entity.Name)
	if err != nil {
		return err
	}

	// Delete the Sensu entity
	log.Printf("Deleting entity (%s/%s)", event.Entity.Namespace, event.Entity.Name)
	if _, err := client.DeleteResource(context.Background(), resource); err != nil {
		if httperr, ok := err.(httpclient.HTTPError); ok {
			if httperr.StatusCode < 500 {
				log.Printf("Entity already deleted (%s/%s)", event.Entity.Namespace, event.Entity.Name)
				return nil
			}
		}
		return err
	}

	return nil
}

func readCAFile(reader io.Reader) (*x509.Certificate, error) {
	certData, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, fmt.Errorf("Unable to load trusted-ca-file: %s", err)
	}
	block, _ := pem.Decode(certData)
	if block == nil {
		return nil, fmt.Errorf("Unable to decode trusted-ca-file.  Is it in PEM format?")
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("Invalid trusted-ca-file: %s", err)
	}
	if !cert.IsCA {
		return nil, fmt.Errorf("Certificate in trusted-ca-file is not a CA")
	}
	return cert, nil
}
